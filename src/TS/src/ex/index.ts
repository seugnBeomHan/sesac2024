/**
 * TS에서 JS에 있는 수만은 API의 타입일 알고, 매개변수와 반환 타입을 강제할 수 있는 이유는
 * lib.d.ts 라는 파일에 모든 JS API들에 대해서 타입 정의가 되어 있기 때문이다.
 * 
 * 해서 우리는 JS에 기존 정의 된 모든 빌트인 함수 및 API에 타입을 적용해
 * 가져다 사용할 수 있게 되는 것이다.
 * 
 * JSDoc을 통해 JS에서 타입스크립트의 타입 체킹 및 추론 기능을
 * 사용할 수 있다.
 * 
 * 주석의 형태로 달아주면, TS 컴파일러가 이를 해석해 적용한다.
 * 
 * //@ts-check 를 JS 파일에 적어주면 적용할 수 있다.
 * 
 * 해서 기존 JS 레거시 역시 TS 컴파일러를 활용해
 * 안전하게 협업할 수 있다.
 * 
 * /**
 * @param {number} num1 
 * @param {number} num2 
 * @returns {number}
 * 
 * 함수마다 위와 같은 형태로 작성하면 타입에 대한 컴파일 타임 확인이 가능하다.
 */

const first = () => { console.log("Hello World"); }

first();

// type 키워드는 새로운 타입을 정의할 때 사용한다.
// 어떤 형태로든 정의가 가능하며, 타입을 정의하는 목적을 가진다.
// 기본 타입 뿐 아니라 객체 원형, 함수 시그니처도 정의할 수 있다.ㅏ
type newNumber = number;
type newString = string;

// 아래와 같이 객체 리터럴의 원형을 선언해 Humen이라는 타입으로 정의할 수 있다.
type Humen = {
    name: string
    age: newNumber
    addr: string
    married: boolean
    school?: newString
}

// 사용하는 경우 위 Humen 타입의 key - value가 모두 동일한 이름과 타입으로 구성되어야 한다.
// name > mame이라고 쓰면 안된다. 결국 내부 프로퍼티를 비교해 동일 타입인지 아닌지 확인하기 때문
const user: Humen = {
    name: "Han",
    age: 27,
    addr: "서울시",
    married: false
}

// interface는 type 과 비슷한 역할을 한다. 하지만 다른 점이 있다.
// 1. 기본 타입에 대한 구문 형태로 정의는 불가능하다.타입명 = 타입; 의 형태는 불가하다.
// 2. 중복 선언이 가능하며, 이땐 해당 타입 내부 속성이 합쳐진다.
// 3. interface 확장 시 extends 키워드를 사용해 확장하며, type 보다 직관적이다.
// 4. class 에도 확장이 가능하며, implements 키워드를 통해 확장한다. 다른 객체지향 언어들과 비슷하다.
interface Humen2 {
    name: string
    age: number
    addr: number
    married: boolean
    // ?의 경우 옵셔널로, Humen2 타입의 객체 생성 시 값을 넣어주지 않아도 된다.
    // 옵셔널의 경우 항상 | undefined 타입이 붙게 된다. 즉 현재 school의 타입은 string | undefined인 유니온 타입이다.
    school?: newString
}

// enum 타입이다. enum의 경우 주로 상태 값들을 부여할 때 사용하는 타입이다.
// 원래는 문자열을 통해 const openState = 'OPEN' 이런식으로 작성해 사용했다.
// 하지만 이 방식의 문제는 문자열에 오타가 있다면 (openState === "OOPEN") false가 반환 되는 등의 문제가 있다.
// enum은 이를 완전히 방지하고, STATE 라는 타입이 생성되고, STATE에 정의 된 값만 자동완성을 통해 사용할 수 있다.
// 그렇기에 에러가 발생할 확률이 훨씬 낮아지고, STATE라는 타입을 활용해 더 명확하게 프로그래밍 할 수 있다. 
enum STATE {
    OPEN = 10, // index : 0 / 시작 값을 변경할 수 있으며(타입도 변경 가능하다. 그냥 문자열을 넣어주면 된다.)
    // 기본은 0이지만 10으로 할 경우 CLOSE는 11의 값을 가진다.
    CLOSE,     // index : 1
    ING,       // index : 2
    LENGTH     // 약간의 테크닉으로 이렇게 LENGTH를 잡아주면 0부터 시작하기에 전체 개수를 파악할 수 있다.
    // 나중에 반복문을 돌 때 index로 활용할 수도 있다.
}

// 이렇게 상태 비교를 하면 훨씬 더 명확하고 안전하게 프로그래밍 할 수 있다.
// enum은 상태들의 묶음에 대한 새로운 타입 지정이다.
const isOpen = (state: STATE): boolean => {
    return state === STATE.OPEN;
}

/**
 * 타입 추론 (Type Inference) 라고도 한다.
 * 입력 되는 값을 통해 해당 변수의 타입을 추론하는 것이다.
 * 
 * const reteral 타입이 있다. const 변수의 특징인데 const의 경우
 * 처음 선언 시 값을 할당해야 하기 때문에 해당 값만 들어갈 수 있다는 의미의 타입이다.
 * 즉, 값까지 고정시키는 굉장히 구체적인 타입 선언이 되며, tsc 입장에서도 추론하기 편하다.
 * 
 * 만약 타입을 지정할 수 없는 객체 리터럴의 경우 [as 타입] 을 사용해 명확하게 타입을 줄 수 있다.
 * [as 타입]을 캐스팅이라고 하며, 이 경우 객체 리터럴의 속성에 타입을 명확하게 지정할 수 있다.
 * 캐스팅을 통해 타입을 지정하면, 다른 타입의 값을 대입할 수 없어 좀더 안전한 프로그래밍이 가능하다.
 * as const의 경우 const 속성을 가진다.
*/


// 이건 바로 객체 리터럴을 생성한 경우이다. 타입을 따로 잡아주지 않아 동일 타입의 객체를
// 매번 값까지 이렇게 선언해야 한다. 이 경우 as 키워드를 사용할 수 있다.
const objA = {
    a: "a" as string,
    b: 1 as number,
    c: true as boolean
}

// 기본적으로 TS는 JS로 컴파일 되기 때문에 JS에 없는 기능은 컴파일 시점에 모두 사라진다.
// 즉 타입 관련 된 부분은 모두 사라진다고 볼 수 있다. 결국 JS에 있는 것들로만 코드를 구성할 것이기 떄문

/**
 * 기본적으로 any는 사용하지 않는다. any를 사용하는 것은 TS를 사용하는 이유에 반하기 떄문이다.
 * 어떤 타입이든 들어올 수 있다는 말은 곧, 타입을 체크하지 않겠다는 것이기 떄문.
 *
 * TS는 타입 추론 기능을 활용해 해당 타입에서 사용할 수 있는 메서드 및 함수의 자동 완성을 보여준다.
 * 만약 타입이 유니온 타입이라면 n개의 타입에서 모두 사용할 수 있는 메서드만 사용 가능하다.
 * 특정 타입에서만 사용할 수 있는 메서드느 사용할 수 없다. 해당 메서드를 가지지 않은 타입의 값도
 * 들어올 수 있기 때문이다. 유니온 타입은 항상 교집합 되어 있는 메서드만 사용할 수 있다.
 */

// 캐스팅 역시 남발하게 되면 TS를 제대로 사용하지 못할 수 있다. number 변수를 string으로 형변환 하는 게 가능하기 때문.

// 결국 any나 casting 같은 게 가능한 이유는 TS코드는 JS로 트랜스컴파일 되기 때문이다. JS에서는 모두 가능하기 때문.
// 해서 any나 강제 형변환 같은 기능은 최대한 사용하지 않고,
// 타입에 맞춰 프로그래밍 하는 게 중요하다.
// 즉 타입과 관련 된 코드는 결국 JS에서는 의미를 가지지 못한다.(네로잉을 위한 코드 등)

/**
 * 유니온은(Union) 타입을 병합하는 기능이다. 하나의 변수에 여러개의 타입을 지정할 수 있다.
 *
 * 이 경우 or로 타입이 지정되는데 number | string | boolean 일 경우
 * 해당 변수는 number or string or boolean 으로 평가되어 3개 타입의 값을 할당 받을 수 있다.
 *
 * 하지만 이 경우 각 타입의 고유한 메서를 사용하려고 하면, 문제가 생긴다.
 *
 * 런타임에 어떤 타입의 값이 들어올 지 TS는 모르기 때문에 위 3개 타입의 교집합에 해당하는 메서드만 사용할 수 있다.
 *
 * 해서 이를 해결하기 위해선 네로잉(narrowing)을 진행해 타입을 명확하게 하나로 좁혀줘야 한다.
 *
 * 또, 유니온은 타입 뿐 아니라 값을 지정할 수도 있다. 즉, 특정 값들만 들어올 수 있는 변수를 만들 수도 있다.
 * enum과 비슷한 기능을 하도록 할 수 있다는 것이다.
 */

/**
 * List의 타입 선언 시 (string | number)[] 와 string[] | number[] 는 다르다.
 *
 * (string | number)[]의 경우 하나의 [] 안에 string 값과 number 값이 모두 들어갈 수 있음을 의미한다.
 * const a = [1, 2, 3, '4', '5'];
 *
 * string[] | number[] 의 경우 하나의 [] 안에 각각 string과 number 값만 들어갈 수 있으며,
 * 이런 배열만 참조하는 변수라는 것이다.
 * const b = [1, 2, 3, 4, 5]; or const b = ['1', '2', '3', '4', '5'];
 */

/**
 * 타입스크립트가 객체 리터럴의 타입을 유추하는 방법은 내부 속성의 개수와 네이밍, 타입이다.
 * 이에 대한 비교를 통해 타입을 유추하며, 커스텀 객체 타입을 유니온으로 가져도, 내부 속성이 다르다면
 * 속성에 대한 값 입력 시 타입을 정확하게 유추할 수 있다.
 */

/**
 * 자주 사용되는 타입의 형태가 있을 경우 이를 type 키워드를 통해 선언해 놓고 사용하게 되면 재사용성을 높일 수 있다.
 */

// 타입에 대한 예외가 발생하면 추론을 할 수 있는지 논리적으로 생각해 보는 게 중요하다.

// intersection 이란 유니온에 반대 되는 개념으로 &로 타입을 엮을 수 있다.
// interface를 조합해 새로운 타입을 만들 때 사용할 수 있을 거 같다.
// type intersection = interface1 & interface2;
// 이 경우 intersection은 interface1과 2의 모든 속성을 필수로 가져야 하는 새로운 타입이 된다.
// 단 primitive 타입의 경우 number & string인 경우가 동시에 존재할 수 없기에 never가 된다.

// -------
/**
 * 경우의 수를 모두 외울 필요 없다.
 * 단지 타입이 추론 가능한 상황인지 논리적으로 생각해 볼 것.
 */
// -------

/**
 * Narrowing은 유니온 타입을 구체화 시키는 것을 말한다.
 * 유니온 타입은 여러개의 타입을 받을 수 있지만
 * 그렇기에 타입 전용 메서드를 호출 할 수 없다.
 *
 * 해서 이 경우 Narrowing을 통해 타입을 구체화 할 필요가 있는 것이다.
 *
 * 총 8가지로 나눠 볼 수 있다.
*/

// 1. Assignment Narrowing
// 특정 값을 할당 해서 구체화 진행
let narrowingA: number | string | boolean = true;
narrowingA; // 이 경우 true 값을 할당 했기 때문에 boolean 타입으로 구체화 된다.

//-----------------------------------------------------

// 2. type of Narrowing
// typeof 키워드를 활용해 변수의 값을 확인하고, 확인 된 값을 통해 타입을 구체화한다.
narrowingA = Math.random() > 0.5 ? 10 : '10'; // 이 경우 다시 number | string 타입이 되었다.
if (typeof narrowingA === 'string') {
    narrowingA; // 이 경우 무조건 string임을 런타임에도 확신할 수 있기에 string 타입으로 구체화 되었다.
} else {
    narrowingA; // 이 경우 역시 무조건 number임을 확신할 수 있기에 number 타입으로 구체화 되었다.
}
// 이 시점에 boolean 타입이 없는 이유는 Math.random()을 통해 number | string 타입으로 구체화 했기 때문이다.

/**
 * typeof 연산자의 한계는 기본 primitive 타입만 비교 가능하다는 것이다.
 * 객체 역시 object로 전부 통일되어 결과가 나온다.
 * 즉, TS 문법을 활용해 정의 된 타입의 경우 비교가 되지 않는다.
 */

//-----------------------------------------------------

// 3. Truthiness Narrowing
// 2번 typeof Narrowing과 동일하다. 단, 따로 typeof 키워드를 사용하지 않고,
// 변수 자체로 그냥 true, false를 판단한다. if(변수) {} else {} 이런식으로.
// 하지만 이런식의 코드는 보는 사람으로 하여금 직관적이지 않기 때문에
// 웬만하면 조건식을 전부 작성해 주는 게 좋을 거 같다.

// 또, 타입을 위해서 조건식을 쓰는 게 비효율적일 거 같지만 어짜피
// 트랜스컴파일 되면 해당 내용은 다 삭제되기 떄문에 런타임에는
// 전혀 영향을 끼치지 않는다. TS에서만 타입 구체화를 위해 활용되는 것이다.

//-----------------------------------------------------

// 4. Equality Narrowing
// 만약 두 변수가 모두 유니온 타입일 때 비교를 한다면?
// 이땐 두 변수가 공통적으로 가지고 있는 타입의 값이 서로 비교가 되었을 땐
// 구체화 되지만 그 밖에 상황에서는 계속 유니온 타입을 유지할 것이다.

let narrowingB: string | boolean = Math.random() > 0.1 ? 'string' : true;
let narrowingC: string | number = Math.random() > 0.1 ? 'false' : 1;

console.log(narrowingB, typeof narrowingB);
console.log(narrowingC, typeof narrowingC);
if (narrowingB === narrowingC) { // 이렇게 할 경우 값까지 비교해 동일 타입이라도 true가 되지 않는다.
    // 타입 비교는 이런식으로 하면 안될 거 같다. typeof 연산자를 쓸 것
    narrowingB;
    narrowingC;

    console.log('서로 다른 string인데 들어올까?');
}

//-----------------------------------------------------

// 5. in operator Narrowing
// in 연산자는 객체 안에 key 이름을 비교하는 것이다.
// 비교할 key 이름 in 객체; 하게 되면
// 우항에 있는 객체 안에 좌항의 이름을 가진 key가 있는지 확인 후
// true, false를 반환하며, 이를 통해 객체 타입을 확인할 수 있다.
// 이때 key 이름은 string 형태로 작성해야 한다.
// string이 아니면 해당 값은 변수로 인식될 것이기 때문.

// 이게 가능한 이유는 결국 TS는 객체 리터럴 비교 시
// 내부 속성의 구성(key 이름, 타입, 개수 등)을 보고
// 객체의 타입을 구분하기 때문이다.

//-----------------------------------------------------

// 6. instenceof Narrowing
/**
 * instenceof 연산자의 경우  프로토타입 체인 안에서 속하는지를
 * 확인한다. 이때 자기보다 자식과의 비교는 확인할 수 없고
 * 자신의 부모와 그 위로 비교를 하며 우항에 있는 타입에 속하는지를 확인한다.
 * 프로토타입 체인을 따라 해당 되는지를 비교한다.
 */

//-----------------------------------------------------

// 7. discrimated Narrowing
/** 
 * 만약 타입을 서로 합쳐야 하는 경우(공통된 속성이 있는 객체 등)
 * 하나에 옵셔널을 주면서 넣는 거 보다는 따로 따로 선언한 다음
 * type 키워드를 통해 하나의 type으로 커스텀 하는 게 낫다.
 * 
 * 위와 같이 했을 때 얻을 수 있는 이점은 하나의 타입으로 구체화 되었을 때
 * 그 속성에 옵셔널이 없기 때문에 속성 역시 구체화가 된다는 것이다.
 * 
 * 하지만 옵셔널이 있다면 하나의 타입으로 구체화가 되어도,
 * 옵셔널 속성은 | undifined를 가지게 될 것이다.
 * 
 * 이는 결국 해당 타입을 온전히 사용할 수 없게 한다.
 */

//-----------------------------------------------------

// 8. exhaustiveness checking
/**
 * never를 이용한 타입 체킹 방법이다.
 * never 타입 변수는 never 타입 값만 받을 있다.
 * 어떤 게 never 타입일까?
 * 절대 값이 들어올 수 없는 상황에 있는 변수가 never 타입으로 구체화 된다.
*/

let nerrowingD: string | number = "string";
if (typeof nerrowingD === 'string') {
    nerrowingD;
} else if (typeof nerrowingD === 'number') {
    nerrowingD;
} else {
    /**
     * 여기에 들어오면 never가 된다. 애초에 위에서 모든 케이스를 적어주었기 때문이다.
     * 해서 이 곳에 절대 들어올 수 없다고 판단했고, 여기 선언되는 nerrowingD 변수는
     * never 타입이 된다. 
     */
    const neverCheck: never = nerrowingD;

    // 만약 런타임 중에 값이 결정되고, 이 값이 유니온의 모든 타입을 아우를 수 있다면?
    // 그리고 nerrowingD 변수에 타입이 추가 된다면 어떻게 될까?
    // 이땐 neverCheck 타입의 변수가 에러가 뜰 것이다. 
    // 위에서 필터링 되지 않은 타입이 never 타입 변수에 할당 될 것이기 때문.
    // 이런 체크를 할 수 있다.
}

/**
 * 기본적으로 함수 파라미터에 대한 타입, 개수, 순서 등의 체크가 진행된다.
 * 옵셔널은 동일하게 적용된다. 즉, 필수로 넣어주지 않아도 될 때 사용할 수 있다.
 * 
 * 이때 주의할 것은 옵셔널 파라미터의 경우 |undifined가 되며,
 * 사용하고자 할 땐 네로잉을 통해 구체화를 진행한 후 사용해야 한다.
 * 
 * 파라미터에 기본값을 줄 수도 있다. 이 경우 옵셔널과는 다르게
 * 따로 입력하지 않으면 기본 값이 적용되고, 타입 역시 넣어준 기본 값의 타입으로 결정된다.
 * 이 땐 |undefined가 아니다. 값의 타입으로 적용된다.
 * 
 * 나머지 파라미터(...args) 의 경우 역시 타입을 정해줘야 하고, 기본적으로 List이다.
 * 즉 들어올 수 있는 값은 리스트이며, 단일 타입 리스트인지, 여러 타입의 값이 들어올 수
 * 있는 List인지 지정해 줄 필요가 있다.
 * 
 * 반환 타입을 명시하지 않으면 return 뒤에 오는 값을 추론해 반환 타입을 지정한다.
 * void 반환 타입이 있다. void는 아무것도 반환 하지 않겠다는 의미로, return 키워드는
 * 사용할 수 있지만 뒤에 값은 줄 수 없다.
 * 
 * undifined를 반환 하는 것과는 다르다. 반환 타입이 undifined라는 것은
 * return undifined를 해줘야 한다. 즉, undifined를 반환한다는 의미이다.
 * 
 * 하지만 void는 정말 아무것도 없다는 의미로 사용된다. 함수 인자 뒤에 : 반환타입 하고 적어준다.
 * 
 * 화살표 함수의 시그니처만 정의할 땐 => 반환타입 해주며, 구현까지 하는 경우
 * () : 반환 타입 => {...} 이렇게 된다.
 * 
 * never 타입이 반환 타입으로 왔을 경우 함수는 절대 반환 되어서는 안된다.
 * 함수의 반환은 곧 함수의 종료를 의미한다. 즉, never 타입이 반환 타입인 경우
 * 해당 함수는 종료 되어서는 안된다. 무한 루프를 돌거나, 예외를 throw 하는 함수일 경우만
 * 반환 타입을 never로 줄 수 있다. 이 역시 필요한 경우 명확한 표현에 사용할 수 있을 거 같다.
*/

/**
 * 함수의 시그니처도 type으로 선언해 커스텀 할 수 있다.
 * 
 * 아래와 같이 정의한 경우 함수의 시그니처가 정의 된 것이다.
 * 
 * 이후 사용시엔 콜백 함수를 인자로 넣어줄 때 타입에 대해서
 * 따로 정의할 필요 없이 콜백함수 명 : addFunc 이런 형태로
 * 넣어주면 된다. 이렇게 되면 해당 콜백함수는 addFunc의
 * 함수 시그니처를 가지게 된다.
 */
type calculator = (num1: number, num2: number) => number;

/**
 * 아래와 같이 사용할 수도 있다. 함수 시그니처를 타입으로 주게 되면
 * 이후 선언되는 파라미터 및 반환 타입을 명시하지 않아도 된다.
 * 
 * 이미 타입으로 선언 된 시그니처에 매개변수 및 반환 타입이 명시되어 있기 때문에
 * 따로 구현 하는 쪽에서는 명시 하지 않아도 추론이 가능하기 때문이다.
 * 
 * 함수 시그니처를 선언할 때 interface로 선언도 가능하다.
 * 여러개를 한 번에 묶어 선언할 수도 있다.
 */
const addCalcul: calculator = (num1, num2) => {
    return num1 + num2;
}

/**
 * 함수 오버로딩도 가능하다. 이때 구현은 하나의 함수만 하고,
 * 나머지 함수들은 함수 명은 동일하게 시그니처만 만들어도 된다.
 * 
 * 단, 구현한 함수가 기준이 되어, 구현한 함수로 커버 가능한
 * 시그니처만 오버로딩이 가능하다. 구현한 함수엔 아예 없는
 * 타입을 가진다던가, 개수가 오히려 많다던가 하게 되면
 * 실제 구현부에서 런타임 시 오류가 발생할 수 있기 때문에
 * 에러가 발생한다. 해서 구현부가 있는 함수의 시그니처가 기준이 된다.
 * 
 * 이때 변수 선언식으로 구현 된 함수는 오버로딩이 불가하다.
 * 애초에 const 및 let 키워드의 경우 호이스팅이 발생하지만
 * 변수의 선언만 호이스팅 되기 때문에 블록 스코프 내
 * 중복 정의가 될 수 없어 오버로딩이 불가하다.
 * function 키워드를 통해 선언 된 함수만 오버로딩이 가능하다.
 */

const overlodingEX = (num: number, str: string, bol: boolean): { name: string } => {

    return { name: "han" };
}

// any 타입은 따로 추론 되지 않는다. 값을 넣어줘도 타입이 바뀌지 않고 any 타입이다.
// 단 Narrowing 은 적용된다.

/**
 * 
 * 1. type vs 2. interface
 * 
 * 1. type만 가능한 기능
 *      1. primitive 변수에 대한 타입 정의
 *      2. 1번에 대한 유니온 정의
 *      3. 식의 형태로 타입을 정의하는 것
 *      4. tuple 타입 정의
 * 
 * 2. interface만 가능한 기능
 *      1. interface merging(중복 선언을 통한 속성 합치기, type은 중복 선언이 안된다)
 *      2. implement나 extends 키워드를 통한 확장 및 상속이 가능하다. (타입의 경우 & 기호를 이용한다)
 *      3. 객체의 타입 선언 시 = 없이 선언 가능하다. interface OBJ {} 이런식으로 가능하다.
 * 
 * 사실 interface는 객체의 형태를 정의할 때 사용하면 가장 좋고,
 * 클래스에 상속 될 때 역시 사용하면 type에 비해 훨씬 명확하다.
 * 
 * 객체지향에서 interface라고 생각해 사용하면 될 거 같다.
 * 이외 표현식 형태로 타입을 정의해야 하면 type을 사용하고, 
 * enum의 경우 여러 옵션 값을 설정할 때 쓰면 좋을 거 같다.
 * 
 * 전부 할 수 있다고 하나로 통일 하는 것 보다는
 * 기능을 필요한 곳에 사용해 명확하게 프로그래밍 하는 게 중요하다.
 */

/**
 * 타입 두개가 공존할 수 없을 때. 즉, number 이면서 string인 상황일 때 never 타입이 된다.
 * (단, 인터페이스는 위와 같은 상황을 아예 예외로 막아버린다.)
 * 
 * interface merging은 동일한 시그니처 및 네로잉 가능한 정도에서
 * 동일 프로퍼티에 대한 타입 변경을 허용한다.
 * 
 * 하지만 유니온이었던 타입을 가진 interface가 extends 되면서
 * 동일한 이름을 가진 프로퍼티가 타입이 하나로 선언된다면,
 * 오버로딩이 일어나면서 해당 타입으로 구체화가 된다. 네로잉 된다.
 * 
 * 단, interface merging은 동일 프로퍼티에 대해서
 * 동일 타입을 유지한 상태여야 하며, 사실
 * 동일 프로퍼티는 따로 선언하지 않고 merging을 하는 게
 * 일반적일 거 같다. 굳이 그럴 필요가 없기 때문.
 */

interface Ractangle {
    width: number | string;
    height: number | string;
}

interface Triangle extends Ractangle {
    width: number;
    height: number;
}

// 아래 코드는 확장 불가능하다. 동일 프로퍼티에 대해 없는 타입으로 선언했기 때문
// interface Triangle extends Ractangle {
//     width: boolean;
//     height: boolean;
// }

// any는 쓰지 않는다!!!!!!!

// TS는 리스트의 인덱스를 확인하지 않는다. [9999] 이렇게 넣어도 에러를 뱉지 않는다.
// 그렇기 때문에 항상 직접 매직 넘버로 넣기 보다는 length 값을 반영한 변수를 통해
// 접근 하는 것이 안전하다.

/**
 * spread operator는 객체 및 배열 내부 값에 대해서 전부 또는 일부를
 * 다른 객체 및 배열에 빠르게 복사하는 문법으로 구조분해할당과 같이 쓰이는 경우가 많다.
 *
 * 구조분해할당은 객체 및 배열을 해체하여, 그 값을 개별 변수에 담을 수 있도록 해주는데
 * 하나의 배열에서 0, 1번째 인덱스의 값은 개별 변수에 각각 담고,
 * 이후 배열에 대해서는 다른 배열로 옮겨 담고자 할 때 같이 사용된다.
 *
 * [index0, index1, ...arrCopy] = arr;
 *
 * 위와 같은 경우 index0 = arr[0]; index1 = arr[1]; 과 동일하며
 * 나머지 배열 값은 arrCopy의 0번 부터 복사되어 들어가게 된다.
 *
 * 스프레드 문법과 구조분해할당을 같이 사용한 예시이다.
 */

// 2차원 배열은 const 2dArr : number[][] = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]];
// 위와 같이 선언하고 할당해 사용하면 된다. 배열 안에 배열이 위치한 상황으로
// 2차원 매트릭스로 보면 된다. 3차원 배열은 number[][][] 하면 된다.

/**
 * 기본적으로 튜블은 배열을 활용한 새로운 타입을 지정하는 것을 말한다.
 * 이때 배열 요소의 타입과 순서, 개수 등이 타입을 결정하게 된다.
 * 
 * 만약 튜플 타입 선언 시 const로 선언하고, 안에 값을 넣어주게 된다면
 * 해당 값을 통해 타입과, 타입의 배치 순서를 추론하고, 
 * 무조건 그 값만 들어올 수 있는 const 튜플이 된다.
 * const [지정한 값, 지정한 값, 지정한 값] 타입의 튜플인 셈이다. 
 */

// 즉 아래와 같이 배열 요소의 타입과 순서, 개수로 튜플 타입을 생성했다.
// 이 경우 순서가 틀리거나 개수가 모자르거나, 타입이 잘못 들어온 경우
// 에러를 발생시키게 된다.
const tuple: [number, string, string, number] = [1, "", "", 2];

// tuple[2] = 10; // 이 경우 index 2번의 타입은 string인데 number를 넣고 있어 예외이다.

/**
 * named tuple의 경우 어떤 값을 입력해야 하는지 지정해 준 튜플이다.
 * 훨씬 직관적이고 협업할 때 해당 튜플을 사용하는 사람 입장에서
 * 도움이 되는 그런 기능이다.
 */

// 이렇게 되면 나중에 warrior 튜플을 쓸 때 각 자리에 어떤 값이 들어가야 하는지 확인이 된다.
let warrior: [name: string, lv: number, str: number, dex: number];

// 튜플 역시 같은 타입만 할당이 가능하다.
// 여기서 타입이라고 하면 같은 배열 구성 요소이다.
// 또, 구체적인 튜플은 덜 구체적인 튜플에 대입이 가능한 반면 그 반대는 불가능하다.

/**
 * 객체 원형 : type이나 interface를 통해 속성명 - 타입만 지정한 객체
 * 객체 리터럴 : 실제 값을 초기화 해 바로 생성한 객체
 * 
 * 객체 리터럴 생성 시 초과 속성 검사를 진행한다.
 * 즉, 객체 원형으로 타입을 지정하고,
 * 객체 리터럴을 생성하면, 객체 원형에 정의 된
 * 속성만 기술할 수 있도록 하는 것이 초과 속성 검사이다.
 */

/**
 * 항상 타입을 명확하게 지정하는 프로그래밍을 하는 게 좋다.
 * 중첩 객체(JSON 형태)를 만들 때도 충첩되는 부분을 하나의 타입으로 만들어
 * 중첨 객체를 구성하는 게 낫다.
 * 
 * interface 객체 원형 a {
 *      속성명 : 타입
 *      속성명 : 타입
 * }
 * 
 * interface 객체 원형A {
 *      속성명 : 객체 원형a
 *      속성명 : 타입
 * }
 * 이렇게 한다음 객체를 선언할 때
 * interface 객체명 : 원형A {
 *      속성명(객체 원형 a 타입) : {
 *          객체 원형 a 속성 1 : 값,
 *          객체 원형 a 속성 2 : 값
 *      },
 *      속성명 : 타입
 * }
 * 이런식으로 구성하는 것이 나중에 에러가 발생했을 때
 * 어떤 인터페이스의 속성이 빠졌는지 알 수 있다.
 * 
 * 이런식으로 타입을 명확하게 지정해 주는 게
 * 추론하기에도 용이하고, 이후 에러가 발생했을 때 역시
 * 도움 받기 용이하다.
 */

/**
 * optional === |undifined이다.
 * 단 optional과 undifined의 차이는
 * optional의 경우 속성을 넣어주지 않아도 되지만
 * undifined의 경우 일단 속성을 넣어주어야 한다.
 * string | undifined 와 optional에서 |undifined 추론한 것은
 * 다르다. 첫 번째 상황은 속성을 넣어 주어야 하고,
 * 두번째는 속성을 넣지 않아도 된다.
 */

/**
 * 유추 된 union의 경우 객체가 런타임 상황에 타입이 결정 될 때
 * 두 객체의 여집합 부분을 optional 속성으로 채우는 것을 말한다.
 * 
 * TS 입장에서는 어떤 객체 타입이 들어올 지 모르는 상황에서
 * 서로 다른 속성을 가지고 있는 객체가 후보군에 있을 때
 * 이를 옵셔널로 두고 판단하는 것이 가장 합리적이기 때문이다.
 * 
 * 이는 모호할 수 있고, 예외가 발생되지 않기 때문에 이 경우
 * undifined인 상태의 값을 가지고 뭔가 로직을 작성할 가능성이 생긴다.
 * 
 * 해서 이런 상황을 방지하려면 미리 객체의 타입을 interface로 선언 후
 * 유니온 타입으로 묶어준 다음, 해당 유니온 타입의 객체를 만들어
 * 코드를 작성하는 것이다. 이렇게 되면 optional로 유추하지도 않을 뿐더러
 * 여집합 속성에 대해서는 네로잉을 진행할 수 있도록 예외를 발생시킨다.
 * 
 * 이땐 in operator 를 활용해 구체화를 진행할 수 있다.
 * 어떤 객체에 특정 속성이 있는지를 확인하는 것이다.
 * 
 * 결국 모든 기능들의 방향이 타입을 명확하게 명시하도록 하고 있다.
 * 즉, 네로잉이 유도되는 방향으로 코드를 작성해야 하며,
 * optional이나 any, unkown이 최대한 적을수록 좋은 코드이다.
 * 
 * 자동으로 optional로 유추되는 상황에서 벗어나
 * 추론이 명확하게 가능하고, 이를 통해 예외를 발생시키는 방향으로
 * 코드를 작성해야 한다.
 */

/**
 * 객체 인터섹션 (object Intersection) 이란 객체 원형, 타입을 서로 묶어
 * 하나의 타입을 만드는 것을 맒한다. 이렇게 만들어진 객체 원형, 타입은
 * 묶인 타입의 모든 속성을 작성해야 예외가 발생하지 않는다.
 * 
 * interface merging이나 interface extends와 비슷하다고 볼 수 있다.
 * 
 * 이땐 유니온과도 인터섹션이 가능한데
 * obj type1 & (obj type2 | obj type3) 형태로 작성하면
 * 무조건 obj type1은 구현이 되어야 하지만 obj type2, 3의 경우
 * 하나의 타입만이라도 제대로 구현이 되어 있으면 된다.
 */

/**
 * keyof 키워드는 객체 원형 타입에 선언된 모든 키를 가지는 타입을 만들 수 있다.
 * type allKeys = keyof 객체 원형 타입;
 * 하게 되면 모든 allkeys는 모든 키를 가지는 타입이 되며,
 * 해당 타입으로 변수를 선언할 경우 해당 변수는 allKeys의 키값 만들 문자열로 가지는 변수가 된다.
 * 
 * 키 밸류 값을 자동으로 매핑 할 수 있는 여러 문법을 제공한다.
 * 즉, 객체 원형 타입을 그대로 복사할 수 있는 기능이다.
 * 
 * 만약 객체 원형 타입을 선언하는데 중복된다고 느낄 때, 기존 객체 원형 타입을 이용해
 * 간편하게 타입을 선언하는데 사용할 수 있을 거 같다.
 */

interface Student {
    name: string,
    age: number,
    grade: number,
    class: number
}

// 위 Student와 비슷한데 grade 와 class 만 없는 객체 원형 타입을 생성하고 싶다면?
// 아래와 같이 작성할 수 있다. 근데 아래와 같은 문법은 type만 된다. interface는 안된다.

type Player = {
    [key in Exclude<keyof Student, 'grade'>]: Student[key];
}

type Player2 = {
    [key in 'name' | 'age']: Student[key];
}

// 확실히 위와 같은 문법이 편리하지만 가독성이 떨어지고,
// 정확히 어떤 목적의 코드인지 알기 어렵다.

// 아래와 같은 경우 key 정보를 모두 알 수 있고,
// studentAllKeys 변수의 경우 Student의 key값을
// 문자열로 가지고 있는 타입이다.
type studentAllKeys = keyof Student;
const keyName: studentAllKeys = "name";
const keyAge: studentAllKeys = "age";
const keyGrade: studentAllKeys = "grade";
const keyClass: studentAllKeys = "class";